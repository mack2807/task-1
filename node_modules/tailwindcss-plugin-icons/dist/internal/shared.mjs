import crypto from 'crypto';
import fs from 'fs';

class TailwindcssPluginIconsError extends Error {
  constructor(message) {
    super(message);
    this.name = "TailwindcssPluginIconsError";
  }
}
function toKebabCase(str) {
  return str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function readJson(path) {
  return JSON.parse(fs.readFileSync(path, "utf8"));
}
function isUri(str) {
  return !str ? false : /^https?:/i.test(str);
}
function uriToFilename(uri) {
  return crypto.createHash("sha1").update(uri).digest("hex");
}
function encodeSvg(svg) {
  if (!svg.includes(" xmlns:xlink=") && svg.includes(" xlink:")) {
    svg = svg.replace(
      "<svg ",
      '<svg xmlns:xlink="http://www.w3.org/1999/xlink" '
    );
  }
  if (!svg.includes(" xmlns=")) {
    svg = svg.replace("<svg ", '<svg xmlns="http://www.w3.org/2000/svg" ');
  }
  return svg.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function parseIconName(iconName) {
  let iconMode;
  const normalizedIconName = toKebabCase(iconName).replace(
    /\?(bg|mask)$/,
    (...values) => {
      iconMode = values[1];
      return "";
    }
  );
  return { normalizedIconName, iconMode };
}
function iconToDataUrl(icon, body = icon.body) {
  const svg = `<svg viewBox="${icon.left} ${icon.top} ${icon.width} ${icon.height}">${body}</svg>`;
  return `url("data:image/svg+xml,${encodeSvg(svg)}")`;
}
function loadIconFromIconifyJson(iconifyJson, iconName) {
  const { icons, aliases, info } = iconifyJson;
  let { left, top, width, height } = iconifyJson;
  const parsedIconName = parseIconName(iconName);
  const { normalizedIconName } = parsedIconName;
  let { iconMode } = parsedIconName;
  let icon;
  if (normalizedIconName in icons) {
    icon = icons[normalizedIconName];
  } else if (aliases && normalizedIconName in aliases) {
    const { parent, ...aliasedIcon } = aliases[normalizedIconName];
    icon = {
      ...icons[parent],
      ...aliasedIcon
    };
  } else {
    throw new TailwindcssPluginIconsError(
      `Icon "${normalizedIconName}" not found${info ? ` in "${info.name}"` : ""}`
    );
  }
  icon.left && (left = icon.left);
  icon.top && (top = icon.top);
  icon.width && (width = icon.width);
  icon.height && (height = icon.height);
  left != null ? left : left = 0;
  top != null ? top : top = 0;
  width != null ? width : width = 16;
  height != null ? height : height = 16;
  iconMode != null ? iconMode : iconMode = icon.body.includes("currentColor") ? "mask" : "color";
  return {
    normalizedName: normalizedIconName,
    body: applyTransformations(icon.body, {
      left,
      top,
      width,
      height,
      rotate: icon.rotate,
      hFlip: icon.hFlip,
      vFlip: icon.vFlip
    }),
    mode: iconMode,
    left,
    top,
    width,
    height
  };
}
function applyTransformations(body, { left, top, width, height, rotate, hFlip, vFlip }) {
  const transform = [];
  if (rotate) {
    const centerX = (2 * left + width) / 2;
    const centerY = (2 * top + height) / 2;
    transform.push(`rotate(${rotate * 90} ${centerX} ${centerY})`);
  }
  if (hFlip) {
    transform.push(`translate(${2 * left + width} 0) scale(-1 1)`);
  }
  if (vFlip) {
    transform.push(`translate(0 ${2 * top + height}) scale(1 -1)`);
  }
  if (transform.length) {
    body = `<g transform="${transform.join(" ")}">${body}</g>`;
  }
  return body;
}

export { TailwindcssPluginIconsError as T, isUri as a, iconToDataUrl as i, loadIconFromIconifyJson as l, readJson as r, toKebabCase as t, uriToFilename as u };

'use strict';

var child_process = require('child_process');
var fs = require('fs');
var path = require('path');
var internal_shared = require('./internal/shared.cjs');
var flattenColorPalette = require('tailwindcss/lib/util/flattenColorPalette');
var plugin = require('tailwindcss/plugin');
require('crypto');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var child_process__default = /*#__PURE__*/_interopDefault(child_process);
var fs__default = /*#__PURE__*/_interopDefault(fs);
var path__default = /*#__PURE__*/_interopDefault(path);
var flattenColorPalette__default = /*#__PURE__*/_interopDefault(flattenColorPalette);
var plugin__default = /*#__PURE__*/_interopDefault(plugin);

class IconifyFileCache {
  constructor(cacheDir) {
    this.cacheDir = cacheDir;
    if (fs__default.default.existsSync(this.cacheDir)) {
      this.size = fs__default.default.readdirSync(this.cacheDir).length;
    } else {
      this.size = 0;
      fs__default.default.mkdirSync(this.cacheDir);
    }
  }
  clear() {
    const files = fs__default.default.readdirSync(this.cacheDir);
    for (const file of files) {
      const filePath = path__default.default.resolve(this.cacheDir, file);
      fs__default.default.unlinkSync(filePath);
    }
    this.size = 0;
  }
  delete(key) {
    const filePath = path__default.default.resolve(this.cacheDir, internal_shared.uriToFilename(key));
    if (!fs__default.default.existsSync(filePath)) {
      return false;
    }
    fs__default.default.unlinkSync(filePath);
    this.size--;
    return true;
  }
  forEach(callbackfn, thisArg = this) {
    for (const [key, value] of this) {
      callbackfn.call(thisArg, value, key, this);
    }
  }
  get(key) {
    const filePath = path__default.default.resolve(this.cacheDir, internal_shared.uriToFilename(key));
    if (!fs__default.default.existsSync(filePath)) {
      return;
    }
    return internal_shared.readJson(filePath);
  }
  set(key, iconifyJson) {
    const filePath = path__default.default.resolve(this.cacheDir, internal_shared.uriToFilename(key));
    if (fs__default.default.existsSync(filePath)) {
      return this;
    }
    this.size++;
    fs__default.default.writeFileSync(filePath, JSON.stringify(iconifyJson));
    return this;
  }
  has(key) {
    const filePath = path__default.default.resolve(this.cacheDir, internal_shared.uriToFilename(key));
    return fs__default.default.existsSync(filePath);
  }
  entries() {
    return this[Symbol.iterator]();
  }
  *keys() {
    yield* fs__default.default.readdirSync(this.cacheDir);
  }
  *values() {
    const files = fs__default.default.readdirSync(this.cacheDir);
    for (const file of files) {
      const filePath = path__default.default.resolve(this.cacheDir, file);
      yield internal_shared.readJson(filePath);
    }
  }
  *[Symbol.iterator]() {
    const files = fs__default.default.readdirSync(this.cacheDir);
    for (const file of files) {
      const filePath = path__default.default.resolve(this.cacheDir, file);
      yield [file, internal_shared.readJson(filePath)];
    }
  }
  get [Symbol.toStringTag]() {
    return `IconifyFileCache(size=${this.size})`;
  }
}

const SCALE = Symbol("Icon-specific scaling");
const URL_VAR_NAME = "--tw-plugin-icons-url";
function getIconDimensions(icon, scale) {
  return {
    width: `${icon.width / icon.height * scale}em`,
    height: `${scale}em`
  };
}
function getIconCss(icon, cssDefaults) {
  const iconUrl = internal_shared.iconToDataUrl(icon);
  const iconDimensions = getIconDimensions(icon, cssDefaults[SCALE]);
  if (icon.mode === "mask") {
    return {
      [URL_VAR_NAME]: iconUrl,
      mask: `var(${URL_VAR_NAME}) no-repeat`,
      maskSize: "100% 100%",
      backgroundColor: "currentColor",
      ...iconDimensions,
      ...cssDefaults
    };
  }
  return {
    [URL_VAR_NAME]: iconUrl,
    background: `var(${URL_VAR_NAME}) no-repeat`,
    backgroundSize: "100% 100%",
    ...iconDimensions,
    ...cssDefaults
  };
}
function getIconCssAsColorFunction(icon, cssDefaults) {
  return (color) => {
    return {
      [URL_VAR_NAME]: internal_shared.iconToDataUrl(
        icon,
        icon.body.replace(/currentColor/g, color)
      ),
      background: `var(${URL_VAR_NAME}) no-repeat`,
      backgroundSize: "100% 100%",
      ...getIconDimensions(icon, cssDefaults[SCALE]),
      ...cssDefaults
    };
  };
}

const cache = new IconifyFileCache(path__default.default.resolve(__dirname, "cache"));
function resolveIconSets(iconSetOptionsRecord, callback) {
  var _a;
  const locationsToFetch = [];
  const afterFetchCallbacks = [];
  for (const [iconSetName, iconSetOptions] of Object.entries(
    iconSetOptionsRecord
  )) {
    (_a = iconSetOptions.icons) != null ? _a : iconSetOptions.icons = {};
    const kebabCaseIconSetName = internal_shared.toKebabCase(iconSetName);
    if (!iconSetOptions.location) {
      try {
        const jsonPath = require.resolve(
          `@iconify-json/${kebabCaseIconSetName}/icons.json`
        );
        callback(
          kebabCaseIconSetName,
          iconSetOptions,
          internal_shared.readJson(jsonPath)
        );
        continue;
      } catch (e) {
        if (e instanceof internal_shared.TailwindcssPluginIconsError) {
          throw e;
        }
      }
      try {
        const jsonPath = require.resolve(
          `@iconify/json/json/${kebabCaseIconSetName}.json`
        );
        callback(
          kebabCaseIconSetName,
          iconSetOptions,
          internal_shared.readJson(jsonPath)
        );
        continue;
      } catch (e) {
        if (e instanceof internal_shared.TailwindcssPluginIconsError) {
          throw e;
        }
      }
      throw new internal_shared.TailwindcssPluginIconsError(
        `Icon set "${iconSetName}" not found. Please see if the name is correct or try installing it with "npm install @iconify-json/${kebabCaseIconSetName}"`
      );
    }
    if (internal_shared.isUri(iconSetOptions.location)) {
      if (cache.has(iconSetOptions.location)) {
        callback(
          kebabCaseIconSetName,
          iconSetOptions,
          cache.get(iconSetOptions.location)
        );
      } else {
        locationsToFetch.push(iconSetOptions.location);
        afterFetchCallbacks.push(() => {
          callback(
            kebabCaseIconSetName,
            iconSetOptions,
            cache.get(iconSetOptions.location)
          );
        });
      }
      continue;
    }
    let resolvedLocation;
    try {
      resolvedLocation = require.resolve(iconSetOptions.location);
    } catch {
      resolvedLocation = path__default.default.resolve(iconSetOptions.location);
    }
    if (!fs__default.default.existsSync(resolvedLocation)) {
      throw new internal_shared.TailwindcssPluginIconsError(
        `No icon set found at "${iconSetOptions.location}"`
      );
    }
    callback(
      kebabCaseIconSetName,
      iconSetOptions,
      internal_shared.readJson(resolvedLocation)
    );
    continue;
  }
  if (!locationsToFetch.length) {
    return;
  }
  child_process__default.default.execFileSync(
    "node",
    [path__default.default.resolve(__dirname, "fetch.mjs"), cache.cacheDir, ...locationsToFetch],
    {
      stdio: "pipe"
    }
  );
  afterFetchCallbacks.forEach((cb) => cb());
}
const addIconToComponents = (components, backgroundComponents) => ({
  iconifyJson,
  iconName,
  iconSetName,
  cssDefaults = {},
  scale = 1
}) => {
  var _a;
  const loadedIcon = internal_shared.loadIconFromIconifyJson(iconifyJson, iconName);
  Object.defineProperty(cssDefaults, SCALE, {
    value: (_a = cssDefaults[SCALE]) != null ? _a : typeof scale === "function" ? scale(iconName) : scale,
    enumerable: false,
    writable: false,
    configurable: false
  });
  if (loadedIcon.mode === "bg") {
    backgroundComponents[`bg-${iconSetName}-${loadedIcon.normalizedName}`] = getIconCssAsColorFunction(
      loadedIcon,
      cssDefaults
    );
  } else {
    components[`.i-${iconSetName}-${loadedIcon.normalizedName}`] = getIconCss(
      loadedIcon,
      cssDefaults
    );
  }
  return loadedIcon;
};
const Icons = plugin__default.default.withOptions((options) => (pluginApi) => {
  const components = {};
  const backgroundComponents = {};
  const addIcon = addIconToComponents(components, backgroundComponents);
  const onResolve = (iconSetName, { icons, scale, includeAll }, iconifyJson) => {
    if (includeAll) {
      Object.keys(iconifyJson.icons).forEach((iconName) => {
        addIcon({ iconifyJson, iconName, iconSetName, scale });
      });
      if (iconifyJson.aliases) {
        Object.keys(iconifyJson.aliases).forEach((iconName) => {
          addIcon({ iconifyJson, iconName, iconSetName, scale });
        });
      }
    }
    Object.entries(icons).forEach(([iconName, cssDefaults]) => {
      addIcon({ iconifyJson, iconName, iconSetName, cssDefaults, scale });
    });
  };
  try {
    resolveIconSets(options(pluginApi), onResolve);
  } catch (e) {
    if (e instanceof Error) {
      console.error("[TailwindcssPluginIcons]", e.message);
    }
    return;
  }
  pluginApi.addComponents(components);
  pluginApi.matchComponents(backgroundComponents, {
    values: flattenColorPalette__default.default(pluginApi.theme("colors")),
    type: ["color", "any"]
  });
});

exports.Icons = Icons;
exports.SCALE = SCALE;
